# 151.翻转字符串里的单词

- **平台**：LeetCode
- **链接**：https://leetcode.cn/problems/reverse-words-in-a-string/description/
- **难度**：Medium
- **标签**：双指针、字符串

## 题目描述

给你一个字符串 `s`，请你反转字符串中**单词**的顺序。

**单词**是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的**单词**分隔开。

返回**单词**顺序颠倒且**单词**之间用单个空格连接的结果字符串。

**注意**：输入字符串 `s` 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

### 示例

**示例 1：**
```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**
```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

**示例 3：**
```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

### 提示

- `1 <= s.length <= 10^4`
- `s` 包含英文大小写字母、数字和空格 `' '`
- `s` 中**至少存在一个**单词

### 进阶

如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的**原地**解法。

## 解题思路

### 方法一：原地反转（推荐）

这是一个经典的字符串反转问题，核心思路是**两次反转**：

1. **第一步**：反转整个字符串
2. **第二步**：反转每个单词
3. **同时处理空格**：移除前导、尾随和单词间的多余空格

**算法步骤：**
1. 反转整个字符串（如 `"the sky is blue"` → `"eulb si yks eht"`）
2. 遍历字符串，找到每个单词的边界
3. 反转每个单词（如 `"eulb"` → `"blue"`）
4. 在反转过程中，使用双指针移除多余空格

**时间复杂度**：`O(n)`，其中 n 是字符串长度  
**空间复杂度**：`O(1)` 或 `O(n)`（取决于语言，Python和Go字符串不可变需要O(n)）

### 方法二：辅助函数分步处理（双指针优化）

将问题分解为三个独立的函数：
1. `removeExtraSpaces`：**使用快慢双指针移除多余空格**
   - `fastIndex`（快指针）：遍历整个字符串
   - `slowIndex`（慢指针）：标记新字符串的有效长度
   - 最后通过 `resize` 调整字符串大小，避免多次 `erase` 操作
2. `reverse`：反转字符串的指定区间
3. `reverseWords`：主函数，先移除空格，再反转整个字符串，最后反转每个单词

这种方法代码结构更清晰，便于理解和维护，且通过双指针优化确保了 O(n) 的时间复杂度。

**时间复杂度**：`O(n)`（避免了 erase 在循环中的 O(n²) 问题）  
**空间复杂度**：`O(1)` 或 `O(n)`

### 方法三：双端队列

使用双端队列（deque）的特性：
1. 去除前导和尾随空格
2. 遍历字符串，提取每个单词
3. 将单词从队列头部插入（`push_front`）
4. 最后拼接所有单词

这种方法思路简单，但空间复杂度较高。

**时间复杂度**：`O(n)`  
**空间复杂度**：`O(n)`

## 代码实现

本题提供了三种语言的实现：

- **C++**：提供了三种解法（原地反转、辅助函数、双端队列）
- **Python**：使用辅助函数分步处理的方法
- **Go**：使用原地反转的方法

详见代码文件：
- [C++ 实现](./151_翻转字符串里的单词.cpp)
- [Python 实现](./151_翻转字符串里的单词.py)
- [Go 实现](./151_翻转字符串里的单词.go)

## 性能优化分析

### 为什么使用双指针而不是erase？

**时间复杂度问题：**

如果使用 `erase` 操作来移除空格，可能会遇到性能问题：
- `erase` 操作本身的时间复杂度就是 **O(n)**（需要移动后续所有元素）
- 如果在 `for` 循环中使用 `erase`，总体时间复杂度会达到 **O(n²)**
- 对于长字符串，性能差距会非常明显

**双指针法的优势：**

使用双指针法（快慢指针）移除冗余空格可以达到 **O(n)** 的时间复杂度：
- `fastIndex`：快指针，遍历整个字符串
- `slowIndex`：慢指针，标记处理后字符串的有效长度
- 最后使用 `resize` 重新设置字符串大小，只需要一次操作

**实现思路：**
1. 去掉字符串前面的空格（fastIndex 跳过前导空格）
2. 去掉字符串中间的冗余空格（只保留单词间的单个空格）
3. 去掉字符串末尾的空格（通过 resize 或 slowIndex 控制）

**为什么在LeetCode上性能差异不明显？**
1. LeetCode 测试集中的字符串长度通常不够长
2. LeetCode 的耗时测量不够精确
3. 当字符串足够长时，O(n) 和 O(n²) 的差距会非常显著

**结论**：虽然 `erase` 方法在 LeetCode 上也能通过，但**双指针法是更优的解决方案**，特别是在处理长字符串时。

## 关键点

1. **双指针技巧**：用于移除多余空格和定位单词边界，fastIndex（快）和slowIndex（慢）配合使用
2. **性能优化**：避免在循环中使用 erase 操作（O(n²)），使用双指针 + resize 实现 O(n) 复杂度
3. **原地操作**：C++中可以直接修改string，Python和Go需要转换为可变类型（list或[]byte）
4. **边界处理**：注意前导空格、尾随空格和单词间多个空格的情况
5. **两次反转**：整体反转 + 局部反转，是这类问题的经典解法

## 相关题目

- [557. 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)
- [186. 反转字符串中的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)
- [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)