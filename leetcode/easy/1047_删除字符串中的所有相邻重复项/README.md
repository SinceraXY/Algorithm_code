# 1047. 删除字符串中的所有相邻重复项

- **平台**：LeetCode
- **链接**：https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/
- **难度**：Easy
- **标签**：栈、字符串

## 题目描述

给出由小写英文字母组成的字符串 `s`，**重复删除**相邻且相同的字母对，直到无法继续删除。

更正式地说，如果在字符串中存在两个相邻字符 `s[i] == s[i+1]`，则删除这两个字符并将剩余字符拼接。重复该过程直到不存在这样的相邻字符。

返回最终得到的字符串。

## 示例

**示例 1：**
```
输入：s = "abbaca"
输出："ca"
解释：
例如："abbaca" -> "aaca" -> "ca"
```

**示例 2：**
```
输入：s = "azxxzy"
输出："ay"
```

## 解题思路

### 方法：栈

**核心思路：**
- 使用栈来模拟“相邻重复就消除”的过程。
- 从左到右遍历字符串：
  - 若当前字符与栈顶字符相同，说明形成一对相邻重复字符，弹出栈顶（等价于删除这一对）。
  - 否则把当前字符入栈。
- 遍历结束后，栈中剩余字符按顺序拼接就是最终答案。

## 代码实现

### C++

在下面的 C++ 代码中，由于 `std::string` 类本身就提供了类似「入栈」和「出栈」的接口，因此我们直接将需要被返回的字符串作为栈即可。对于其他的语言，如果字符串类没有提供相应的接口，则需要在遍历完成字符串后，使用栈中的字符显式地构造出需要被返回的字符串。

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string stk;
        for (char ch : s) {
            if (!stk.empty() && stk.back() == ch) {
                stk.pop_back();
            } else {
                stk.push_back(ch);
            }
        }
        return stk;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是字符串的长度。我们只需要遍历该字符串一次。
- **空间复杂度**：O(n) 或 O(1)，取决于使用的语言提供的字符串类是否提供了类似「入栈」和「出栈」的接口。注意返回值不计入空间复杂度。

## 关键点

1. 栈顶与当前字符相同就弹栈，等价于“删除相邻重复项”。
2. C++ 中可以用 `std::string` 直接作为栈，通过 `push_back` / `pop_back` 操作。
3. 遍历结束后返回栈内剩余字符即可。