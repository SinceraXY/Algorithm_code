# 数组算法专题 (Array Algorithms)

## 📚 专题目录
- [数组基础](#数组基础)
- [二分查找](#二分查找)
- [双指针技术](#双指针技术)
- [滑动窗口](#滑动窗口)
- [前缀和技术](#前缀和技术)
- [差分数组](#差分数组)
- [数组排序](#数组排序)
- [经典题目](#经典题目)

---

## 🎯 数组基础

### 数组特性
- **连续内存**: 元素在内存中连续存储
- **随机访问**: O(1) 时间复杂度访问任意元素
- **固定大小**: 创建后大小通常不可变
- **索引访问**: 通过下标 `0 ~ n-1` 访问元素

### 基本操作复杂度
| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问元素 | O(1) | 直接通过索引访问 |
| 搜索元素 | O(n) | 无序数组线性搜索 |
| 插入元素 | O(n) | 需要移动后续元素 |
| 删除元素 | O(n) | 需要移动后续元素 |
| 排序 | O(n log n) | 快排、归并等高效算法 |

---

## 🔍 二分查找

### 核心思想
在**有序数组**中使用分治策略，每次将搜索范围缩小一半，快速定位目标元素。

### 标准模板
```cpp
// 标准二分查找 - 查找目标值
int binarySearch(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 防止整数溢出
        
        if (nums[mid] > target) {
            right = mid - 1;                   // 目标在左半部分
        } else if (nums[mid] < target) {
            left = mid + 1;                    // 目标在右半部分
        } else {
            return mid;                        // 找到目标
        }
    }
    
    return -1;  // 未找到目标
}
```

### 搜索插入位置
```cpp
// LeetCode 35: 搜索插入位置
int searchInsert(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] >= target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return left;  // 返回插入位置
}
```

### 查找边界
```cpp
// 查找目标值的左边界
int leftBound(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] >= target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}

// 查找目标值的右边界
int rightBound(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return right;
}
```

### 二分查找变种
1. **旋转数组搜索** (LeetCode 33)
2. **寻找峰值** (LeetCode 162)  
3. **搜索二维矩阵** (LeetCode 74)
4. **寻找两个正序数组的中位数** (LeetCode 4)

---

## 👥 双指针技术

### 对撞指针
两个指针从数组两端向中间移动，通常用于有序数组。

```cpp
// 两数之和 II - 输入有序数组 (LeetCode 167)
vector<int> twoSum(vector<int>& numbers, int target) {
    int left = 0, right = numbers.size() - 1;
    
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        
        if (sum == target) {
            return {left + 1, right + 1};  // 返回1-indexed
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    
    return {};
}
```

### 快慢指针
两个指针以不同速度遍历数组，常用于去重、环检测等。

```cpp
// 删除排序数组中的重复项 (LeetCode 26)
int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0;
    
    int slow = 0;
    for (int fast = 1; fast < nums.size(); fast++) {
        if (nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    
    return slow + 1;
}
```

### 同向双指针
两个指针同向移动，维护某种窗口或区间。

```cpp
// 移动零 (LeetCode 283)
void moveZeroes(vector<int>& nums) {
    int slow = 0;
    
    // 快指针遍历，慢指针指向下一个非零元素应该放置的位置
    for (int fast = 0; fast < nums.size(); fast++) {
        if (nums[fast] != 0) {
            nums[slow++] = nums[fast];
        }
    }
    
    // 将剩余位置填充为0
    while (slow < nums.size()) {
        nums[slow++] = 0;
    }
}
```

---

## 🪟 滑动窗口

### 核心思想
维护一个窗口在数组上滑动，通过调整窗口大小来找到满足条件的子数组。

### 固定窗口
```cpp
// 长度为K的子数组的最大值 (LeetCode 239)
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;  // 存储数组下标
    vector<int> result;
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除窗口外的元素
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // 移除比当前元素小的元素
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // 窗口形成后记录最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}
```

### 可变窗口
```cpp
// 无重复字符的最长子串 (LeetCode 3)
int lengthOfLongestSubstring(string s) {
    unordered_set<char> window;
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        // 收缩窗口直到没有重复字符
        while (window.count(s[right])) {
            window.erase(s[left]);
            left++;
        }
        
        window.insert(s[right]);
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

---

## 📊 前缀和技术

### 一维前缀和
```cpp
// 构建前缀和数组
vector<int> buildPrefixSum(vector<int>& nums) {
    vector<int> prefixSum(nums.size() + 1, 0);
    
    for (int i = 0; i < nums.size(); i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    
    return prefixSum;
}

// 查询区间和 [left, right]
int rangeSum(vector<int>& prefixSum, int left, int right) {
    return prefixSum[right + 1] - prefixSum[left];
}
```

### 二维前缀和
```cpp
// 二维区域和检索 (LeetCode 304)
class NumMatrix {
private:
    vector<vector<int>> prefixSum;
    
public:
    NumMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        prefixSum = vector<vector<int>>(m + 1, vector<int>(n + 1, 0));
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefixSum[i][j] = prefixSum[i-1][j] + prefixSum[i][j-1] 
                                - prefixSum[i-1][j-1] + matrix[i-1][j-1];
            }
        }
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        return prefixSum[row2+1][col2+1] - prefixSum[row1][col2+1] 
             - prefixSum[row2+1][col1] + prefixSum[row1][col1];
    }
};
```

### 前缀和应用
- **子数组和为K** (LeetCode 560)
- **连续数组** (LeetCode 525)
- **和为s的连续正数序列** (剑指Offer 57-II)

---

## 📈 差分数组

### 核心思想
差分数组是前缀和的逆操作，用于**频繁的区间更新**操作。

```cpp
// 差分数组模板
class Difference {
private:
    vector<int> diff;
    
public:
    Difference(vector<int>& nums) {
        diff = vector<int>(nums.size());
        diff[0] = nums[0];
        
        for (int i = 1; i < nums.size(); i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }
    
    // 区间 [i, j] 增加 val
    void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.size()) {
            diff[j + 1] -= val;
        }
    }
    
    // 恢复原数组
    vector<int> result() {
        vector<int> res(diff.size());
        res[0] = diff[0];
        
        for (int i = 1; i < diff.size(); i++) {
            res[i] = res[i - 1] + diff[i];
        }
        
        return res;
    }
};
```

### 应用场景
- **区间加法** (LeetCode 370)
- **航班预订统计** (LeetCode 1109)
- **拼车** (LeetCode 1094)

---

## 📋 数组排序

### 常见排序算法

#### 快速排序
```cpp
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    
    int pivot = partition(nums, left, right);
    quickSort(nums, left, pivot - 1);
    quickSort(nums, pivot + 1, right);
}

int partition(vector<int>& nums, int left, int right) {
    int pivot = nums[right];
    int i = left - 1;
    
    for (int j = left; j < right; j++) {
        if (nums[j] <= pivot) {
            i++;
            swap(nums[i], nums[j]);
        }
    }
    
    swap(nums[i + 1], nums[right]);
    return i + 1;
}
```

#### 归并排序
```cpp
void mergeSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    
    int mid = left + (right - left) / 2;
    mergeSort(nums, left, mid);
    mergeSort(nums, mid + 1, right);
    merge(nums, left, mid, right);
}

void merge(vector<int>& nums, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            temp[k++] = nums[i++];
        } else {
            temp[k++] = nums[j++];
        }
    }
    
    while (i <= mid) temp[k++] = nums[i++];
    while (j <= right) temp[k++] = nums[j++];
    
    for (int i = 0; i < temp.size(); i++) {
        nums[left + i] = temp[i];
    }
}
```

### 特殊排序问题
- **颜色分类** (LeetCode 75) - 荷兰国旗问题
- **数组中的第K个最大元素** (LeetCode 215) - 快速选择
- **合并区间** (LeetCode 56) - 按起始位置排序

---

## 🎯 经典题目

### 基础题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 26 | 删除排序数组中的重复项 | Easy | 快慢指针 |
| 27 | 移除元素 | Easy | 双指针 |
| 35 | 搜索插入位置 | Easy | 二分查找 |
| 53 | 最大子数组和 | Easy | 动态规划/前缀和 |
| 88 | 合并两个有序数组 | Easy | 双指针 |

### 进阶题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 15 | 三数之和 | Medium | 排序+双指针 |
| 33 | 搜索旋转排序数组 | Medium | 二分查找变种 |
| 56 | 合并区间 | Medium | 排序+贪心 |
| 238 | 除自身以外数组的乘积 | Medium | 前缀积+后缀积 |
| 560 | 和为K的子数组 | Medium | 前缀和+哈希表 |

### 困难题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 4 | 寻找两个正序数组的中位数 | Hard | 二分查找 |
| 42 | 接雨水 | Hard | 双指针/单调栈 |
| 239 | 滑动窗口最大值 | Hard | 单调队列 |

---

## 🔧 解题技巧总结

### 1. 题目类型识别
- **有序数组** → 考虑二分查找
- **求子数组** → 考虑滑动窗口、前缀和
- **数组操作** → 考虑双指针
- **区间问题** → 考虑差分数组

### 2. 时间复杂度优化
- **O(n²) → O(n log n)**: 使用排序
- **O(n²) → O(n)**: 使用双指针、滑动窗口
- **O(n) → O(log n)**: 使用二分查找

### 3. 空间复杂度优化
- **原地算法**: 双指针技术
- **滚动数组**: 动态规划优化
- **位运算**: 状态压缩

### 4. 边界条件处理
- **数组为空**: `nums.empty()`
- **单元素数组**: `nums.size() == 1`
- **整数溢出**: `left + (right - left) / 2`
- **越界访问**: 检查索引范围

---

## 📚 学习路径

### 第一阶段: 基础掌握
1. **数组遍历**: 理解基本操作
2. **双指针**: 对撞指针、快慢指针
3. **二分查找**: 标准模板、边界处理

### 第二阶段: 技巧运用
1. **滑动窗口**: 固定窗口、可变窗口
2. **前缀和**: 一维、二维前缀和
3. **排序算法**: 快排、归并、特殊排序

### 第三阶段: 综合应用
1. **差分数组**: 区间更新操作
2. **单调栈/队列**: 特殊数据结构
3. **复杂场景**: 多技巧组合运用

---

*专题创建时间: 2025-08-13*
*适用于: LeetCode、面试准备、算法竞赛*
