# 哈希表算法专题 (Hash Table Algorithms)

## 📚 专题目录
- [哈希表基础](#哈希表基础)
- [数组作为哈希表](#数组作为哈希表)
- [字典映射技巧](#字典映射技巧)
- [计数统计](#计数统计)
- [快速查找](#快速查找)
- [去重与集合](#去重与集合)
- [哈希冲突处理](#哈希冲突处理)
- [经典题目](#经典题目)

---

## 🎯 哈希表基础

### 哈希表特性
- **键值映射**: 通过哈希函数将键映射到存储位置
- **快速访问**: O(1) 平均时间复杂度的查找、插入、删除
- **无序存储**: 元素存储顺序与插入顺序无关
- **唯一键值**: 每个键只能对应一个值

### 基本操作复杂度
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 说明 |
|------|----------------|----------------|------|
| 查找元素 | O(1) | O(n) | 哈希冲突严重时退化 |
| 插入元素 | O(1) | O(n) | 需要处理冲突和扩容 |
| 删除元素 | O(1) | O(n) | 删除后可能需要重新哈希 |
| 遍历所有元素 | O(n) | O(n) | 需要访问所有键值对 |

### 哈希表实现方式
```cpp
// C++ 中的哈希表实现
#include <unordered_map>
#include <unordered_set>

unordered_map<int, string> hashMap;  // 键值对映射
unordered_set<int> hashSet;          // 去重集合
```

```python
# Python 中的哈希表实现
hash_map = {}                        # 字典（键值对）
hash_set = set()                     # 集合（去重）
from collections import defaultdict, Counter
```

```go
// Go 中的哈希表实现
hashMap := make(map[int]string)      // 键值对映射
hashSet := make(map[int]bool)        // 模拟集合
```

---

## 🔢 数组作为哈希表

### 适用场景
- 键的范围有限且已知（如小写字母、数字范围）
- 需要O(1)空间复杂度
- 避免哈希冲突的开销

### 经典应用：字母统计
```cpp
// 统计小写字母出现次数
int count[26] = {0};
for (char c : str) {
    count[c - 'a']++;  // 字符映射到数组索引
}
```

### 数组哈希表的优势
- **空间效率高**: 固定大小，无额外开销
- **访问速度快**: 直接数组访问，无哈希计算
- **无冲突**: 完美哈希函数，无冲突处理

---

## 📖 字典映射技巧

### 1. 键值对存储
```python
# 存储索引映射
index_map = {}
for i, val in enumerate(nums):
    index_map[val] = i  # 值 -> 索引

# 存储频次映射  
freq_map = {}
for item in items:
    freq_map[item] = freq_map.get(item, 0) + 1
```

### 2. 多值映射
```python
from collections import defaultdict

# 分组映射
groups = defaultdict(list)
for item in items:
    key = get_key(item)
    groups[key].append(item)
```

### 3. 反向映射
```python
# 原映射: name -> id
name_to_id = {"Alice": 1, "Bob": 2}

# 反向映射: id -> name
id_to_name = {v: k for k, v in name_to_id.items()}
```

---

## 📊 计数统计

### Counter 的妙用
```python
from collections import Counter

# 字符计数
char_count = Counter("hello world")
# Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})

# 最常见元素
most_common = char_count.most_common(3)  # 前3个最常见

# 计数运算
count1 = Counter(['a', 'b', 'c', 'a'])
count2 = Counter(['a', 'b', 'b'])
count1 + count2  # 计数相加
count1 - count2  # 计数相减
count1 & count2  # 交集
count1 | count2  # 并集
```

### 手动计数模板
```cpp
// C++ 计数模板
unordered_map<int, int> count;
for (int num : nums) {
    count[num]++;
}

// 检查计数
if (count[target] > 0) {
    // 目标存在
}
```

---

## 🔍 快速查找

### 1. 两数之和模式
```python
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
```

### 2. 存在性判断
```python
# 快速判断元素是否存在
def contains_duplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False
```

### 3. 最近访问记录
```python
# LRU Cache 的核心思想
class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> value
        self.order = []  # 访问顺序
```

---

## 🎨 去重与集合

### 集合运算
```python
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}

intersection = set1 & set2    # 交集 {3, 4}
union = set1 | set2           # 并集 {1, 2, 3, 4, 5, 6}
difference = set1 - set2      # 差集 {1, 2}
symmetric_diff = set1 ^ set2  # 对称差集 {1, 2, 5, 6}
```

### 去重应用
```cpp
// 数组去重
vector<int> removeDuplicates(vector<int>& nums) {
    unordered_set<int> seen;
    vector<int> result;
    for (int num : nums) {
        if (seen.find(num) == seen.end()) {
            seen.insert(num);
            result.push_back(num);
        }
    }
    return result;
}
```

---

## ⚔️ 哈希冲突处理

### 1. 链地址法
```
索引 0: [key1, val1] -> [key5, val5] -> NULL
索引 1: [key2, val2] -> NULL  
索引 2: [key3, val3] -> [key6, val6] -> [key9, val9] -> NULL
```

### 2. 开放地址法
```
线性探测: hash(key) + i (i = 0, 1, 2, ...)
二次探测: hash(key) + i² (i = 0, 1, 2, ...)
双重哈希: hash1(key) + i * hash2(key)
```

### 3. 扩容策略
- **负载因子**: 当 load_factor = size/capacity > 0.75 时扩容
- **扩容倍数**: 通常扩容为原来的2倍
- **重新哈希**: 所有元素需要重新计算位置

---

## 🏆 经典题目

### 初级题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 1 | 两数之和 | Easy | 哈希表查找互补数 |
| 242 | 有效的字母异位词 | Easy | 字符计数 |
| 383 | 赎金信 | Easy | 字符频次匹配 |
| 349 | 两个数组的交集 | Easy | 集合运算 |
| 350 | 两个数组的交集II | Easy | 计数匹配 |

### 中级题目  
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 15 | 三数之和 | Medium | 哈希表+双指针 |
| 18 | 四数之和 | Medium | 多层哈希查找 |
| 454 | 四数相加II | Medium | 分组哈希 |
| 49 | 字母异位词分组 | Medium | 分组映射 |
| 128 | 最长连续序列 | Medium | 哈希表+贪心 |

### 高级题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 146 | LRU缓存 | Medium | 哈希表+双向链表 |
| 460 | LFU缓存 | Hard | 多层哈希映射 |
| 295 | 数据流的中位数 | Hard | 哈希表+堆 |

---

## 💡 解题技巧总结

### 1. 选择合适的数据结构
- **计数问题**: 使用 `Counter` 或 `unordered_map<T, int>`
- **存在性判断**: 使用 `set` 或 `unordered_set`  
- **键值映射**: 使用 `dict` 或 `unordered_map`
- **有限范围**: 使用数组模拟哈希表

### 2. 常见模式识别
- **两数之和**: 遍历时查找互补数
- **字母异位词**: 字符计数或排序比较
- **分组问题**: 按特征值分组映射
- **去重问题**: 使用集合数据结构

### 3. 优化策略
- **空间换时间**: 用哈希表缓存计算结果
- **预处理**: 将数据预先存入哈希表
- **边界优化**: 提前检查长度、空值等边界条件
- **内存优化**: 合理选择哈希表大小，避免过度扩容

### 4. 注意事项
- **哈希冲突**: 了解底层实现，预估性能影响
- **内存开销**: 哈希表有额外的内存开销
- **顺序问题**: 哈希表不保证元素顺序
- **键的类型**: 确保键类型是可哈希的

---

## 🔧 实用代码模板

### Python 模板
```python
# 计数模板
from collections import Counter, defaultdict

def count_elements(arr):
    counter = Counter(arr)
    return counter

# 分组模板
def group_by_key(items):
    groups = defaultdict(list)
    for item in items:
        key = get_key(item)  # 自定义键函数
        groups[key].append(item)
    return dict(groups)

# 查找模板
def find_pair(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        if target - num in seen:
            return [seen[target - num], i]
        seen[num] = i
    return []
```

### C++ 模板
```cpp
#include <unordered_map>
#include <unordered_set>

// 计数模板
unordered_map<int, int> countElements(vector<int>& nums) {
    unordered_map<int, int> count;
    for (int num : nums) {
        count[num]++;
    }
    return count;
}

// 去重模板
vector<int> removeDuplicates(vector<int>& nums) {
    unordered_set<int> seen;
    vector<int> result;
    for (int num : nums) {
        if (seen.insert(num).second) {  // 插入成功说明是新元素
            result.push_back(num);
        }
    }
    return result;
}
```

哈希表是算法面试中的高频考点，掌握其核心思想和常见模式对提升解题效率非常重要！
