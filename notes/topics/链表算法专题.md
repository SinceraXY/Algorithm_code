# 链表算法专题 (Linked List Algorithms)

## 📚 专题目录
- [链表基础](#链表基础)
- [虚拟头节点技巧](#虚拟头节点技巧)
- [双指针技术](#双指针技术)
- [链表反转](#链表反转)
- [链表合并](#链表合并)
- [环形链表](#环形链表)
- [链表排序](#链表排序)
- [经典题目](#经典题目)

---

## 🎯 链表基础

### 链表特性
- **动态内存**: 节点在内存中不连续存储
- **顺序访问**: 只能从头节点开始顺序访问
- **动态大小**: 可以在运行时动态增删节点
- **指针连接**: 通过指针将节点连接成链

### 基本操作复杂度
| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问元素 | O(n) | 需要从头开始遍历 |
| 搜索元素 | O(n) | 线性搜索 |
| 插入元素 | O(1) | 已知位置时 |
| 删除元素 | O(1) | 已知位置时 |
| 获取长度 | O(n) | 需要遍历整个链表 |

### 链表节点定义
```cpp
// C++ 链表节点定义
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

```python
# Python 链表节点定义
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

```go
// Go 链表节点定义
type ListNode struct {
    Val  int
    Next *ListNode
}
```

---

## 🎭 虚拟头节点技巧

### 核心思想
设置一个虚拟头节点（dummy head），统一处理头节点和其他节点的操作，简化边界条件处理。

### 适用场景
- **删除节点**: 避免头节点删除的特殊处理
- **插入节点**: 统一插入逻辑
- **链表合并**: 简化合并过程
- **链表构建**: 方便从空链表开始构建

### 标准模板
```cpp
// 虚拟头节点模板
ListNode* processLinkedList(ListNode* head) {
    ListNode* dummy = new ListNode(0);  // 创建虚拟头节点
    dummy->next = head;                 // 指向原头节点
    ListNode* cur = dummy;              // 工作指针
    
    // 进行链表操作
    while (cur->next != nullptr) {
        // 具体操作逻辑
        cur = cur->next;
    }
    
    return dummy->next;  // 返回真正的头节点
}
```

### 移除链表元素实现
```cpp
// LeetCode 203: 移除链表元素
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* cur = dummy;
        
        while (cur->next != nullptr) {
            if (cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;  // 释放内存
            } else {
                cur = cur->next;
            }
        }
        
        return dummy->next;
    }
};
```

---

## 👥 双指针技术

### 快慢指针
两个指针以不同速度遍历链表，常用于环检测、中点查找等。

```cpp
// 链表的中间结点 (LeetCode 876)
ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    // 快指针走两步，慢指针走一步
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;  // 慢指针指向中点
}
```

```cpp
// 环形链表检测 (LeetCode 141)
bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            return true;  // 快慢指针相遇，存在环
        }
    }
    
    return false;
}
```

### 前后指针
两个指针保持固定距离，常用于查找倒数第K个节点。

```cpp
// 删除链表的倒数第N个结点 (LeetCode 19)
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* first = dummy;
    ListNode* second = dummy;
    
    // 第一个指针先走n+1步
    for (int i = 0; i <= n; i++) {
        first = first->next;
    }
    
    // 两个指针同时移动
    while (first != nullptr) {
        first = first->next;
        second = second->next;
    }
    
    // 删除倒数第n个节点
    ListNode* tmp = second->next;
    second->next = second->next->next;
    delete tmp;
    
    return dummy->next;
}
```

---

## 🔄 链表反转

### 迭代法反转
```cpp
// 反转链表 (LeetCode 206)
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* cur = head;
    
    while (cur != nullptr) {
        ListNode* next = cur->next;  // 保存下一个节点
        cur->next = prev;            // 反转指针
        prev = cur;                  // 移动prev
        cur = next;                  // 移动cur
    }
    
    return prev;  // prev是新的头节点
}
```

### 递归法反转
```cpp
// 递归反转链表
ListNode* reverseList(ListNode* head) {
    // 递归终止条件
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    
    // 递归反转子链表
    ListNode* newHead = reverseList(head->next);
    
    // 反转当前节点
    head->next->next = head;
    head->next = nullptr;
    
    return newHead;
}
```

### 反转区间
```cpp
// 反转链表 II (LeetCode 92) - 反转区间[left, right]
ListNode* reverseBetween(ListNode* head, int left, int right) {
    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* pre = dummy;
    
    // 找到反转区间的前一个节点
    for (int i = 0; i < left - 1; i++) {
        pre = pre->next;
    }
    
    ListNode* cur = pre->next;
    
    // 反转区间内的节点
    for (int i = 0; i < right - left; i++) {
        ListNode* next = cur->next;
        cur->next = next->next;
        next->next = pre->next;
        pre->next = next;
    }
    
    return dummy->next;
}
```

---

## 🔗 链表合并

### 合并两个有序链表
```cpp
// 合并两个有序链表 (LeetCode 21)
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    
    while (list1 != nullptr && list2 != nullptr) {
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    }
    
    // 连接剩余节点
    cur->next = (list1 != nullptr) ? list1 : list2;
    
    return dummy->next;
}
```

### 合并K个排序链表
```cpp
// 合并K个升序链表 (LeetCode 23) - 分治法
ListNode* mergeKLists(vector<ListNode*>& lists) {
    if (lists.empty()) return nullptr;
    
    while (lists.size() > 1) {
        vector<ListNode*> mergedLists;
        
        // 两两合并
        for (int i = 0; i < lists.size(); i += 2) {
            ListNode* l1 = lists[i];
            ListNode* l2 = (i + 1 < lists.size()) ? lists[i + 1] : nullptr;
            mergedLists.push_back(mergeTwoLists(l1, l2));
        }
        
        lists = mergedLists;
    }
    
    return lists[0];
}
```

---

## ⭕ 环形链表

### 环检测 - Floyd判圈算法
```cpp
// 环形链表 (LeetCode 141)
bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            return true;
        }
    }
    
    return false;
}
```

### 环入口检测
```cpp
// 环形链表 II (LeetCode 142) - 找环的入口
ListNode* detectCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    // 第一步：检测是否有环
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            // 第二步：找环的入口
            ListNode* ptr = head;
            while (ptr != slow) {
                ptr = ptr->next;
                slow = slow->next;
            }
            return ptr;
        }
    }
    
    return nullptr;
}
```

---

## 📊 链表排序

### 归并排序（推荐）
```cpp
// 排序链表 (LeetCode 148) - O(n log n) 时间，O(1) 空间
ListNode* sortList(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    
    // 找到中点并分割链表
    ListNode* mid = getMid(head);
    ListNode* left = head;
    ListNode* right = mid->next;
    mid->next = nullptr;
    
    // 递归排序
    left = sortList(left);
    right = sortList(right);
    
    // 合并
    return merge(left, right);
}

ListNode* getMid(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    ListNode* prev = nullptr;
    
    while (fast != nullptr && fast->next != nullptr) {
        prev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return prev;
}
```

---

## 🎯 经典题目

### 基础题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 203 | 移除链表元素 | Easy | 虚拟头节点 |
| 206 | 反转链表 | Easy | 迭代/递归 |
| 21 | 合并两个有序链表 | Easy | 双指针 |
| 83 | 删除排序链表中的重复元素 | Easy | 单指针遍历 |
| 141 | 环形链表 | Easy | 快慢指针 |

### 进阶题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 19 | 删除链表的倒数第N个结点 | Medium | 前后指针 |
| 24 | 两两交换链表中的节点 | Medium | 迭代/递归 |
| 92 | 反转链表 II | Medium | 区间反转 |
| 142 | 环形链表 II | Medium | Floyd算法 |
| 143 | 重排链表 | Medium | 找中点+反转+合并 |

### 困难题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 23 | 合并K个升序链表 | Hard | 分治法/优先队列 |
| 25 | K个一组翻转链表 | Hard | 分组反转 |
| 148 | 排序链表 | Medium | 归并排序 |

---

## 🔧 解题技巧总结

### 1. 题目类型识别
- **删除节点** → 考虑虚拟头节点
- **查找位置** → 考虑双指针
- **检测环** → 考虑快慢指针
- **反转操作** → 考虑迭代/递归

### 2. 常用技巧选择
- **虚拟头节点**: 统一处理头节点
- **快慢指针**: 环检测、中点查找
- **前后指针**: 倒数第K个节点
- **分治思想**: 复杂链表操作

### 3. 内存管理
- **C++**: 手动释放删除的节点内存
- **Python/Go**: 自动垃圾回收
- **避免内存泄漏**: 及时释放不用的节点

### 4. 边界条件处理
- **空链表**: `head == nullptr`
- **单节点链表**: `head->next == nullptr`
- **环形链表**: 注意终止条件
- **指针越界**: 检查指针有效性

---

## 📚 学习路径

### 第一阶段: 基础掌握
1. **链表遍历**: 理解基本结构和操作
2. **虚拟头节点**: 掌握统一处理技巧
3. **链表反转**: 迭代和递归两种方法

### 第二阶段: 技巧运用
1. **双指针**: 快慢指针、前后指针
2. **链表合并**: 有序链表合并
3. **环形链表**: Floyd判圈算法

### 第三阶段: 综合应用
1. **复杂反转**: 区间反转、K组反转
2. **链表排序**: 归并排序实现
3. **多链表操作**: K个链表合并

---

## 💡 Python和Go实现要点

### Python特点
```python
# Python链表操作更简洁
def removeElements(head: Optional[ListNode], val: int) -> Optional[ListNode]:
    dummy = ListNode(0)
    dummy.next = head
    cur = dummy
    
    while cur.next:
        if cur.next.val == val:
            cur.next = cur.next.next  # 自动垃圾回收
        else:
            cur = cur.next
    
    return dummy.next
```

### Go语言特点
```go
// Go语言结构体初始化更灵活
func removeElements(head *ListNode, val int) *ListNode {
    dummy := &ListNode{Next: head}  // 简洁初始化
    cur := dummy
    
    for cur.Next != nil {
        if cur.Next.Val == val {
            cur.Next = cur.Next.Next  // 自动内存管理
        } else {
            cur = cur.Next
        }
    }
    
    return dummy.Next
}
```

---

*专题创建时间: 2025-08-19*
*适用于: LeetCode、面试准备、算法竞赛*
