# 字符串算法专题 (String Algorithms)

## 📚 专题目录

### 核心算法
- [字符串基础](#字符串基础)
- [双指针技术](#双指针技术)
- [滑动窗口](#滑动窗口)
- [字符串匹配](#字符串匹配)
- [回文问题](#回文问题)
- [子序列与子串](#子序列与子串)
- [字符串转换](#字符串转换)
- [字符串哈希](#字符串哈希)

### 实战指南
- [经典题目](#经典题目)
- [解题技巧总结](#解题技巧总结)
- [学习路径](#学习路径)
- [实战技巧](#实战技巧)

---

## 🎯 字符串基础

### 字符串特性
- **字符数组**: 本质上是字符数组，C++中以`\0`结尾
- **不可变性**: 某些语言中字符串不可变（如Java、Python）
- **连续存储**: 字符在内存中连续存储
- **随机访问**: O(1) 时间复杂度访问任意字符

### 基本操作复杂度
| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问字符 | O(1) | 直接通过索引访问 |
| 查找子串 | O(n·m) | 朴素算法 |
| 字符串拼接 | O(n) | 需要复制字符 |
| 字符串比较 | O(n) | 逐字符比较 |
| 反转字符串 | O(n) | 需要遍历一半字符 |

---

## 👥 双指针技术

### 核心思想
使用两个指针在字符串上移动，通过不同的移动策略来解决问题。根据移动方向分为对撞指针和同向指针。

### 适用场景
- **反转操作**: 字符串反转、部分反转
- **回文判断**: 验证回文串、找回文子串
- **去重操作**: 删除重复字符、压缩字符串
- **原地修改**: 需要O(1)空间复杂度的场景

### 双指针的优势
- **空间优化**: 原地操作，无需额外数组
- **时间高效**: 一次遍历即可完成，O(n)时间
- **代码简洁**: 逻辑清晰，易于理解和实现

### 对撞指针 - 反转字符串
```cpp
// LeetCode 344: 反转字符串
void reverseString(vector<char>& s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        swap(s[left++], s[right--]);
    }
}
```

### 快慢指针 - 删除重复字符
```cpp
string removeDuplicates(string s) {
    if (s.empty()) return s;
    int slow = 0;
    for (int fast = 1; fast < s.length(); fast++) {
        if (s[fast] != s[slow]) {
            s[++slow] = s[fast];
        }
    }
    return s.substr(0, slow + 1);
}
```

---

## 🪟 滑动窗口

### 核心思想
维护一个窗口在字符串上滑动，通过扩展和收缩窗口来找到满足条件的子串，避免重复计算。

### 适用场景
- **子串问题**: 最长/最短满足条件的子串
- **字符匹配**: 包含特定字符的子串
- **连续序列**: 连续子串的统计问题
- **字符串排列**: 查找排列、异位词

### 滑动窗口的优势
- **时间优化**: 将O(n²)降至O(n)
- **避免重复**: 利用窗口状态，不重复计算
- **模板统一**: 固定窗口和可变窗口使用统一框架

### 标准模板
```cpp
// 滑动窗口标准模板
int slidingWindow(string s) {
    unordered_map<char, int> window;
    int left = 0, right = 0;
    int result = 0;
    
    while (right < s.length()) {
        // 扩大窗口
        char c = s[right];
        right++;
        window[c]++;  // 更新窗口数据
        
        // 收缩窗口
        while (window needs shrink) {
            char d = s[left];
            left++;
            window[d]--;  // 更新窗口数据
        }
        
        // 更新结果
        result = max(result, right - left);
    }
    
    return result;
}
```

### 可变窗口 - 最长无重复子串
```cpp
// LeetCode 3: 无重复字符的最长子串
int lengthOfLongestSubstring(string s) {
    unordered_set<char> window;
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        while (window.count(s[right])) {
            window.erase(s[left++]);
        }
        window.insert(s[right]);
        maxLen = max(maxLen, right - left + 1);
    }
    return maxLen;
}
```

### 最小覆盖子串
```cpp
// LeetCode 76: 最小覆盖子串
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, valid = 0;
    int start = 0, len = INT_MAX;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s[right];
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) valid++;
        }
        
        while (valid == need.size()) {
            if (right - left + 1 < len) {
                start = left;
                len = right - left + 1;
            }
            char d = s[left++];
            if (need.count(d)) {
                if (window[d] == need[d]) valid--;
                window[d]--;
            }
        }
    }
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

---

## 🔍 字符串匹配

### 核心思想
在文本串中查找模式串的位置，KMP算法通过预处理模式串构建next数组，避免重复比较。

### 适用场景
- **子串查找**: 在主串中查找模式串首次出现位置
- **重复模式**: 判断字符串是否由重复子串构成
- **多次匹配**: 在同一文本中多次搜索相同模式

### KMP算法的优势
- **时间优化**: 从O(n·m)降至O(n+m)
- **智能跳过**: 利用已匹配信息，避免回退
- **预处理高效**: next数组构建只需O(m)时间

### 朴素匹配 vs KMP
```cpp
// 朴素匹配: O(n·m)
int naiveSearch(string text, string pattern) {
    for (int i = 0; i <= text.length() - pattern.length(); i++) {
        int j = 0;
        while (j < pattern.length() && text[i + j] == pattern[j]) {
            j++;
        }
        if (j == pattern.length()) return i;
    }
    return -1;
}

// KMP: O(n+m)
// 利用next数组避免重复比较
```

### KMP 算法
```cpp
// LeetCode 28: 找出字符串中第一个匹配项的下标
class Solution {
public:
    vector<int> getNext(string needle) {
        int n = needle.length();
        vector<int> next(n, 0);
        for (int i = 1, j = 0; i < n; i++) {
            while (j > 0 && needle[i] != needle[j]) {
                j = next[j - 1];
            }
            if (needle[i] == needle[j]) j++;
            next[i] = j;
        }
        return next;
    }
    
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        vector<int> next = getNext(needle);
        
        for (int i = 0, j = 0; i < haystack.length(); i++) {
            while (j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) j++;
            if (j == needle.length()) {
                return i - j + 1;
            }
        }
        return -1;
    }
};
```

---

## 🔄 回文问题

### 核心思想
回文串是正读和反读都相同的字符串。可以从中心向两边扩展，或使用动态规划记录状态。

### 适用场景
- **回文判断**: 验证字符串是否为回文
- **最长回文**: 查找最长回文子串
- **回文计数**: 统计所有回文子串数量
- **回文分割**: 将字符串分割成回文片段

### 回文算法对比
| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|-----------|-----------|---------|
| 中心扩展 | O(n²) | O(1) | 找最长回文 |
| 动态规划 | O(n²) | O(n²) | 计数、判断多个 |
| Manacher | O(n) | O(n) | 大规模数据 |

### 中心扩展法优势
- **空间最优**: O(1)空间复杂度
- **实现简单**: 代码简洁易懂
- **实用高效**: 对于中小规模数据足够快

### 中心扩展法
```cpp
// LeetCode 5: 最长回文子串
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";
        int start = 0, maxLen = 0;
        
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = max(len1, len2);
            if (len > maxLen) {
                maxLen = len;
                start = i - (len - 1) / 2;
            }
        }
        return s.substr(start, maxLen);
    }
    
private:
    int expandAroundCenter(string& s, int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
};
```

### 动态规划法
```cpp
// 回文子串计数
int countSubstrings(string s) {
    int n = s.length();
    vector<vector<bool>> dp(n, vector<bool>(n, false));
    int count = 0;
    
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i; j < n; j++) {
            if (s[i] == s[j]) {
                if (j - i <= 1 || dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    count++;
                }
            }
        }
    }
    return count;
}
```

---

## 📝 子序列与子串

### 核心思想
使用动态规划思想，通过子问题的解来构建原问题的解，适合处理序列相关问题。

### 子序列 vs 子串
- **子序列**: 不要求连续，保持相对顺序即可
- **子串**: 必须连续，是原字符串的一个片段

### 适用场景
- **相似度计算**: 两个字符串的相似程度
- **公共部分**: 最长公共子序列/子串
- **序列匹配**: 判断是否为子序列
- **文本比对**: diff算法、版本控制

### 动态规划的优势
- **避免重复**: 记忆化搜索，子问题只计算一次
- **最优子结构**: 通过局部最优得到全局最优
- **状态转移清晰**: 递推关系明确，易于实现

### 最长公共子序列
```cpp
// LeetCode 1143: 最长公共子序列
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.length(), n = text2.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

---

## 🔧 字符串转换

### 核心思想
通过插入、删除、替换等操作将一个字符串转换为另一个，编辑距离衡量两个字符串的相似度。

### 适用场景
- **拼写纠错**: 输入法、搜索引擎的纠错功能
- **DNA序列**: 生物信息学中的序列比对
- **版本比较**: 文件差异分析
- **相似度计算**: 字符串匹配度评分

### 编辑距离的应用
- **Levenshtein距离**: 最经典的编辑距离
- **模糊匹配**: 容错搜索、推荐系统
- **数据清洗**: 识别和合并相似记录

### 编辑距离 DP 状态转移
```
dp[i][j] 表示 word1[0:i] 转换为 word2[0:j] 的最小操作数

如果 word1[i-1] == word2[j-1]:
    dp[i][j] = dp[i-1][j-1]  // 无需操作
否则:
    dp[i][j] = min(
        dp[i-1][j] + 1,      // 删除 word1[i-1]
        dp[i][j-1] + 1,      // 插入 word2[j-1]
        dp[i-1][j-1] + 1     // 替换 word1[i-1]
    )
```

### 编辑距离
```cpp
// LeetCode 72: 编辑距离
int minDistance(string word1, string word2) {
    int m = word1.length(), n = word2.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
            }
        }
    }
    return dp[m][n];
}
```

---

## 🔢 字符串哈希

### 核心思想
将字符串映射为一个数值（哈希值），通过比较哈希值来快速判断字符串是否相等，避免逐字符比较。

### 适用场景
- **快速比较**: O(1)时间判断字符串相等
- **子串匹配**: Rabin-Karp算法
- **重复检测**: 查找重复子串
- **字符串去重**: 大量字符串的快速去重

### 字符串哈希的优势
- **时间高效**: 字符串比较从O(n)降至O(1)
- **空间节省**: 用整数代替字符串存储
- **实现简单**: 滚动哈希易于实现

### 哈希函数设计
```cpp
// 多项式哈希（常用）
hash = (s[0] * base^(n-1) + s[1] * base^(n-2) + ... + s[n-1]) % mod

// 常用参数
const int base = 131;     // 或 13331
const int mod = 1e9 + 7;  // 大质数
```

### 滚动哈希实现
```cpp
class RollingHash {
private:
    const long long base = 131;
    const long long mod = 1e9 + 7;
    vector<long long> hash;  // 前缀哈希
    vector<long long> power; // base的幂次
    
public:
    RollingHash(string s) {
        int n = s.length();
        hash.resize(n + 1, 0);
        power.resize(n + 1, 1);
        
        // 构建前缀哈希和幂次数组
        for (int i = 0; i < n; i++) {
            hash[i + 1] = (hash[i] * base + s[i]) % mod;
            power[i + 1] = (power[i] * base) % mod;
        }
    }
    
    // 获取子串 [l, r) 的哈希值
    long long getHash(int l, int r) {
        long long h = (hash[r] - hash[l] * power[r - l] % mod + mod) % mod;
        return h;
    }
};
```

### 应用：重复子串模式
```cpp
// LeetCode 459: 重复的子字符串
bool repeatedSubstringPattern(string s) {
    int n = s.length();
    RollingHash rh(s);
    
    // 尝试所有可能的长度
    for (int len = 1; len <= n / 2; len++) {
        if (n % len != 0) continue;
        
        long long firstHash = rh.getHash(0, len);
        bool isRepeat = true;
        
        // 检查所有片段是否相同
        for (int i = len; i < n; i += len) {
            if (rh.getHash(i, i + len) != firstHash) {
                isRepeat = false;
                break;
            }
        }
        
        if (isRepeat) return true;
    }
    
    return false;
}
```

### 注意事项
- **哈希冲突**: 不同字符串可能有相同哈希值
- **模数选择**: 选择大质数减少冲突
- **溢出处理**: 使用long long和取模运算
- **多重哈希**: 使用多个哈希函数降低冲突概率

---

## 🎯 经典题目

### 基础题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 344 | 反转字符串 | Easy | 双指针 |
| 541 | 反转字符串 II | Easy | 双指针 |
| 151 | 反转字符串中的单词 | Medium | 双指针+原地 |
| 242 | 有效的字母异位词 | Easy | 哈希表 |
| 383 | 赎金信 | Easy | 哈希表 |
| 125 | 验证回文串 | Easy | 双指针 |

### 滑动窗口题目
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 3 | 无重复字符的最长子串 | Medium | 滑动窗口 |
| 76 | 最小覆盖子串 | Hard | 滑动窗口 |
| 438 | 找到字符串中所有字母异位词 | Medium | 固定窗口 |
| 567 | 字符串的排列 | Medium | 固定窗口 |

### 回文问题
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 5 | 最长回文子串 | Medium | 中心扩展/DP |
| 647 | 回文子串 | Medium | 中心扩展/DP |
| 131 | 分割回文串 | Medium | 回溯+DP |
| 516 | 最长回文子序列 | Medium | DP |

### 字符串匹配
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 28 | 找出字符串中第一个匹配项的下标 | Easy | KMP |
| 459 | 重复的子字符串 | Easy | KMP |
| 686 | 重复叠加字符串匹配 | Medium | KMP |

### 动态规划
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 72 | 编辑距离 | Hard | DP |
| 1143 | 最长公共子序列 | Medium | DP |
| 583 | 两个字符串的删除操作 | Medium | DP |
| 392 | 判断子序列 | Easy | 双指针/DP |
| 115 | 不同的子序列 | Hard | DP |

### 综合应用
| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|----------|
| 394 | 字符串解码 | Medium | 栈 |
| 224 | 基本计算器 | Hard | 栈+表达式求值 |
| 49 | 字母异位词分组 | Medium | 哈希表 |
| 165 | 比较版本号 | Medium | 双指针+分割 |

---

## 🔧 解题技巧总结

### 1. 题目类型识别
- **反转/对称** → 双指针
- **子串/子序列** → 滑动窗口/DP
- **模式匹配** → KMP/字符串哈希
- **回文判断** → 中心扩展/DP/Manacher
- **字符统计** → 哈希表
- **字符串转换** → DP（编辑距离）

### 2. 时间复杂度优化
- **O(n·m) → O(n+m)**: KMP算法
- **O(n²) → O(n)**: 滑动窗口、中心扩展
- **O(n³) → O(n²)**: 动态规划
- **O(n²) → O(n)**: Manacher算法（回文）

### 3. 空间复杂度优化
- **滚动数组**: DP优化
- **原地操作**: 双指针技术
- **字符数组**: 小字符集用数组代替哈希表（26字母）

### 4. 常见技巧
- **预处理**: 字符串哈希、前缀和
- **虚拟字符**: 处理边界（Manacher中的'#'）
- **哨兵节点**: 简化边界条件
- **状态压缩**: 用整数表示字符集合

### 5. 边界条件处理
- **空字符串**: `s.empty()` 或 `s.length() == 0`
- **单字符**: `s.length() == 1`
- **字符集**: ASCII（128）还是小写字母（26）
- **整数溢出**: 字符串哈希时使用取模运算
- **大小写**: 是否需要统一转换

---

## 📚 学习路径

### 第一阶段: 基础掌握（1-2周）
1. **字符串遍历**: 理解基本操作和API
2. **双指针技术**: 反转、回文判断
3. **哈希表应用**: 字符统计、异位词

**推荐题目**: 344, 242, 383, 125, 541, 151

### 第二阶段: 技巧运用（2-3周）
1. **滑动窗口**: 固定窗口、可变窗口
2. **回文问题**: 中心扩展、动态规划
3. **字符串匹配**: 朴素算法、KMP

**推荐题目**: 3, 438, 567, 5, 647, 28, 459

### 第三阶段: 进阶算法（3-4周）
1. **动态规划**: LCS、编辑距离
2. **字符串哈希**: Rabin-Karp、滚动哈希
3. **综合应用**: 栈、回溯等

**推荐题目**: 72, 1143, 76, 394, 131, 115

### 第四阶段: 专题深化（长期）
1. **字典树**: 前缀匹配、单词搜索
2. **后缀数组**: 高级字符串结构
3. **AC自动机**: 多模式匹配
4. **Manacher算法**: 线性时间回文

---

## 💡 实战技巧

### 调试技巧
```cpp
// 打印字符串状态
void debugString(string s, int left, int right) {
    cout << "String: " << s << endl;
    cout << "Window: [" << left << ", " << right << "]" << endl;
    cout << "Substring: " << s.substr(left, right - left + 1) << endl;
}
```

### 性能优化
1. **避免频繁拼接**: 使用 `StringBuilder`（Java）或 `stringstream`（C++）
2. **字符数组优化**: 小字符集用数组代替哈希表
3. **预分配空间**: `reserve()` 方法避免重复分配
4. **引用传递**: 避免不必要的字符串复制

### 常见陷阱
1. **字符集假设**: 题目是否包含特殊字符、数字
2. **大小写敏感**: 是否需要统一转换
3. **Unicode字符**: 多字节字符的处理
4. **整数溢出**: 字符串哈希时的取模
5. **字符串不可变**: Java/Python中的字符串不可变性